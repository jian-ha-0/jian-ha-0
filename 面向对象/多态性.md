对象的多态性：父类的引用指向子类的对象

有对象多态性后：我们在编译器只能调用父类的方法，但运行时执行的是子类重写的方法，所以：编译看左边，运行看右边

多态情况下，

“看左边”：看的是父类的引用（父类中不具备子类特有的方法）

“看右边”：看的是子类的对象（实际运行的是子类重写父类的方法）。

多态的使用前提：
1：类的继承关系
2:父类方法的重写

而且只适用于方法，不适用于属性

java多态的好处：
　　（1）可替换性(substitutability)。多态对已存在代码具有可替换性。例如，多态对圆Circle类工作，对其他任何圆形几何体，如圆环，也同样工作。
　　（2）可扩充性(extensibility)。多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。例如，在实现了圆锥、半圆锥以及半球体的多态基础上，很容易增添球体类的多态性。
　　（3）接口性(interface-ability)。多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。
　　（4）灵活性(flexibility)。它在应用中体现了灵活多样的操作，提高了使用效率。
　　（5）简化性(simplicity)。多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。
　　注意：优先级从高到低：this.show(O)、super.show(O)、


this.show((super)O)、super.show((super)O)。
Map<String,String> map1 = new HashMap<String,String>();
Map<String,String> map2 = new TreeMap<String,String>();
统一类型 ,多种形态
Map为接口, 相当于对外访问点, 不同实现, HashMap ,TreeMap ,相当于不同形态
多态,可以理解为一致类型,不同形态,
好处在于统一对外的访问点, 却可以自定义形态功能 ,灵活`


有了对象的多态性以后，内存中实际上是加载了子类特有的
属性和方法，但是由于变量声明为父类类型，导致编译时，只能调用父类
中声明的属性和方法。子类的属性和方法不能调用。

多态发生时，子类只能调用父类中的方法（编译时类型的方法），而子类自己独有的方法（运行时类型的方法）无法调用，如果强制调用的话就需要向下转型，语法和基本类型的强制类型转换一样；但是向下转型具有一定的风险，很有可能无法成功转化，为了判断能否成功转化，就需要 instanceof 先进行一个判断，然后再进行转换操作；

使用强转时，可能出现 ClassCastException 异常


instanceof 是一个运算符：
a instanceof  A
如果返回true 就代表a是A的实例，如果不是就会返回false


![[Pasted image 20221026124705.png]]